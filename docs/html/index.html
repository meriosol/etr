<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta httpEquiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Event tracker (ETR)</title>
<link href="css/main.css" rel="stylesheet" type="text/css"/>
</head>
<body>

<body>
<h1>Event tracker (ETR)</h1>

<table>
	<tbody>
		<tr>
			<td>Project:</td>
			<td>Event tracker</td>
		</tr>
		<tr>
			<td>Inception:</td>
			<td>2014-01-13</td>
		</tr>
		<tr>
			<td>Goal:</td>
			<td>
			Based on sample of event domain model show how different combinations of industry popular
			(Java) frameworks(frmk-s)/approaches can be used to handle events. For persistence entity CRUD operations in different DBs to be explored.</td>
		</tr>
	</tbody>
</table>

<h2>Contents</h2>
<ul>
	<li><a href="#Introduction">Introduction</a></li>
	<li><a href="#1_Requirements">1. Requirements/wishes/dreams</a></li>
	<li><a href="#1_1_Language">1.1. Language/frmk combinations</a></li>
	<li><a href="#1_2_Traits_to_consider">1.2. Traits to consider/embrace in selected persistent frmk-s</a></li>
	<li><a href="#1_3_Sample_test">1.3. Sample test cases for persistent frmk-s</a></li>
	<li><a href="#1_4_Implemented_approaches">1.4. Implemented approaches for persistent frmk-s</a></li>
	<li><a href="#2_Design">2. Design</a></li>
    <li><a href="#2_1_Class_high_level">2.1. Class high level structure</a></li>
    <li><a href="#2_1_1_POJOs">2.1.1. POJOs</a></li>
    <li><a href="#2_1_2_DAOs">2.1.2. DAOs (or Mappers in ORMs)</a></li>
    <li><a href="#2_2_Data_high_level">2.2. Data high-level structure</a></li>
    <li><a href="#2_3_Project_structure">2.3. Project structure</a></li>
    <li><a href="#2_4_Build">2.4. Build</a></li>
	<li><a href="#3_Persistence_DAO">3. Persistence DAO approaches overview</a></li>
	<li><a href="#3_1_JDBC">3.1. JDBC</a></li>
    <li><a href="#4_Disclaimers">4. Disclaimers</a></li>
    <li><a href="#5_Abbreviations">5. Abbreviations</a></li>
</ul>
	
<h2><a id="Introduction">Introduction</a></h2>
There are tons of approaches to work with popular frmks e,g, for databases persistence. It's easy to get lost among them even if you're seasoned developer.
Once you start this endeavour, you realise that documentation varies from frmk to frmk in details and quality, 
sample code and configs are not for combination you assess, particular versions of frmk-s don't 
live together well. Forums - though useful, sometimes more confuse than help. It's especially common when the newest frmk versions are emerged
(notice this set of projects generally grabs the latest stable version of whichever frmk).<br> 
Another way to look at it: you joined new team. They use some combination of frmk-s which you didn't try. 
Codebase is large and not easy to grasp at once. Performance optimizations and bug fixes/workarounds can greatly reduce code readability. 
Yes, there are books, forums, guru fellows who can help out. But forums can mislead(for instance discuss elder frmk versions), gurus are busy
, and you want to see sample actionable code and run it now, learn in a matter of minutes how 
typical combination of those frmk-s works, how much config/code it "consumes". This project tries to 
embrace it via providing code snippets and configs which proven to work for particular frmk-s(generally the newest on time of addition).  

<h2><a id="1_Requirements">1. Requirements/wishes/dreams</a></h2>
Use cases are extremely simple from high level:
<div>
<img src="img/main_use_cases.jpg" alt="Main use cases" />
</div>

For 'Manage Event' main scenarios are: 'create','update','delete','retrieve'(a few methods e.g. per category or severity, sorted by date, paginated). 
Actors/users can be humans or machines. As a sample: event producer can generate events and send them to topic/queue. 
Event consumers can be users who monitor events via dashboards. WebSocket clients can setup tcp 
connection from browser to topic/queue consumers and listen to new events in real time. 
Consumers can be also CEP(Complex Event Processing) systems. They can detect predetermined patterns 
(e.g. 10 ERROR events from one source during 1 minute) and generate alerts(events themselves). Some sort of AI/machine learning can be applied too if time allows. 
Another area is BPM (Business Process Management). They can be launched by events (or particular steps triggered) or produce events.
So only imagination(and author lifespan) limits cases where events can be explored.

<h3><a id="1_1_Language">1.1. Language/frmk combinations</a></h3>
Current selection snapshot:

<pre>
(lang: Java SE v7) (frmk: JDBC v4+ | JPA v2+ | Spring v4+ | Hibernate v4+ | Mybatis v3+) 
(DB: SQL: (derby v10+ | mysql v5+| pgsql v9+) NoSQL: (Cassandra 2+ | Solr 4.7+)) (config: XML | Annotations).
</pre>

<div class="note">  
TODO: Consider Spring Data for persistence.
</div>  
<p>
You can ask why for DBs there are no e.g. Oracle, IBM DB2. They are solid, matured DBs. For now they are ignored 
for the sake of DB setup simplicity(e.g. try to find oracle for win7 64x machine which doesn't eat a few gigs of your HDD). 
Only immensely popular, easily available and open source DBs are selected. 
</p>

<div class="note">  
TODO: Well, it would be fair to add at least one of big guys DB (Oracle?) and stored procedures via JDBC can be explored.
</div>  
<p>
	Side notes:
	<ul>
		<li>It's incredible hard to embrace all combinations, so only some "mainstream" will be selected.</li>
		<li>"Container less" variations are considered only. JPA is the closest to JavaEE though.
		It's selected to avoid any clutter of additional configuring and dependencies from any EE container.
		Despite of it those testing DAOs will likely be used in EE containers for testing web-middleware-backend path.</li>
		<li>Some of frmk-s can be combined in "chains" e.g. (JPA + Spring + Hibernate). Folders and odcs will help to determine which combinatiopn is supported.</li>
		<li>No embedded DBs/modes are chosen. They are perceived as too far from PROD ready apps. Apache Derby (or JavaDB as modern name) has embedded mode. 
		You can test it if you wish.</li> 
	</ul>
</p>

<p>
	Current iteration (Mar 2014) already embraced planned SQL and NoSQL DBs persistence. Next iterations can embrace e.g.:
	<ul>
		<li>(JavaEE: version: (v6 | v7) ; profile: (web | full))
		<li>(lang: (Java SE 7 | JVM: (groovy v2+ | scala)) | python | perl | MS.Net: (c#))
		<li>  (DB: SQL: (Oracle)) (NoSQL: (MongoDB | Neo4j)) (idea is to embrace major NoSQL DB types: key/value or columnar, document, graph)
		<li>2nd level caching (notice ehcache is already used in a few persistence combinations)	 
	</ul>
</p>

<h3><a id="1_2_Traits_to_consider">1.2. Traits to consider/embrace in selected persistent frmk-s</a></h3>
<ul>
	<li>How easy to code/config a solution.</li>
	<li>Transaction(TX) support for ACID DBs(mostly SQL, but e.g. graph DB neo4j supports ACID too).</li>
	<li>XA distributed TX support (2 phase commits; JavaEE container is required).</li>
	<li>Date handling support (on very basic level; as a sample of not totally primitive data type).</li>
	<li>PK support. Client and DB side PK generation. Interesting case is complex keys support. Many legacy databases have composite keys.</li>
	<li>How easily Object/Relational mismatch is handled(those inheritance hierarchies).</li>
	<li>"Reconfigurability" (especially for env specific params).</li>
	<li>Pagination support (can be critical for large storage).</li>
	<li>Lazy loading (again critical for big data).</li>
	<li>Large data types support(for now long string is enough; e.g. via Clob or longvarchsr).</li>
	<li>Performance: latency, throughput.</li>
	<li>Memory consumption.</li>
	<li>Multi-threading support(how frmk-s sustain concurrent use; mutasker external lib can be used for load tests).</li>
	<li>Security (secured passwords, connections etc. Can be too large topic for this small project).</li>
	<li>Caching(consider <em>ehcache</em> as a sample).</li>
	<li>i18n(e.g. using UTF-8 charset for data).</li>
</ul>

<h3><a id="1_3_Sample_test">1.3. Sample test cases for persistent frmk-s</a></h3>
<ul>
	<li>Create event</li>
	<li>Update event fields</li>
	<li>Retrieve event by ID</li>
	<li>Retrieve limited amount of recent events(useful for feeds)</li>
	<li>Retrieve events for period (check cases where some or all date params are null)</li>
	<li>Delete event by ID</li>
</ul>

<h3><a id="1_4_Implemented_approaches">1.4. Implemented approaches for persistent frmk-s</a></h3>
Base dir is <b>projects/java_se7_sql/approaches</b>.
<table>
	<thead>
		<tr>
			<th>Approach</th>
			<th>Module path</th>
		</tr>
	</thead>		
	<tbody>
		<tr>
			<td>Cassandra/CQL</td>
			<td>cassandra/cql</td>
		</tr>
		<tr>
			<td>Hibernate/JPA/Annotations</td>
			<td>hibernate/jpa/annot</td>
		</tr>
		<tr>
			<td>Hibernate/Spring/Annotations</td>
			<td>hibernate/spring/annot</td>
		</tr>
		<tr>
			<td>Hibernate/Spring/JPA/Annotations</td>
			<td>hibernate/spring/jpa/annot</td>
		</tr>
		<tr>
			<td>Hibernate/Spring/XML</td>
			<td>hibernate/spring/xml</td>
		</tr>
		<tr>
			<td>Hibernate/XML</td>
			<td>hibernate/xml</td>
		</tr>
		<tr>
			<td>JDBC</td>
			<td>jdbc</td>
		</tr>
		<tr>
			<td>MyBatis/Annotations</td>
			<td>mybatis/annot</td>
		</tr>
		<tr>
			<td>MyBatis/Spring/Annotations</td>
			<td>mybatis/spring/annot</td>
		</tr>
		<tr>
			<td>MyBatis/XML</td>
			<td>mybatis/xml</td>
		</tr>
		<tr>
			<td>Solr/Direct</td>
			<td>solr/direct</td>
		</tr>
		<tr>
			<td>Spring/Templates</td>
			<td>spring/templates</td>
		</tr>
		
		
	</tbody>
</table>


It's expected for codebase to show some of them, but not all. Each module should describe what feature set is implemented. 

<h2><a id="2_Design">2. Design</a></h2>
Main idea of design is to create easily 'buildable' mini projects frmk which allows to quickly add and test frmk-s combination.
To simplify at least one aspect of system entities are planned to be used exactly the same and considered as "frozen".

<h3><a id="2_1_Class_high_level">2.1. Class high level structure</a></h3>
Domain and DAO classes:
<div>
<img src="img/etr_main_persistence_classes.jpg" alt="Main persistence classes" />
</div>
DAO interfaces - more details: 
<div>
<img src="img/etr_dao_interfaces_detailed.jpg" alt="DAO interfaces" />
</div>

<h4><a id="2_1_1_POJOs">2.1.1. POJOs</a></h4>
Main POJO classes to play with are: 
<pre>
  Event(id: long, category: Event.Category, severityLevel: enum(INFO/WARN/ERROR/FATAL)
        , source: string, processId: string, title: short_string, created: date_time).
</pre>

Supplement entity is dict of event categories: 
<pre>
  Event.Category(code: string, name: string). 
</pre>

These classes are suitable for lists and eager relationships mapping.<br>
For more detailed info subclasses are to be used(likely in the next iteration):

<pre>
  DetailedEvent extends Event (info: long_string).
  DetailedEvent.Category extends Event.Category(desc: long_string).
</pre>
   
They are expected to be used only for individual entity editing.  

Sample:
<pre>
  Event(id: 123439887656, categoryCode: "START", severityLevel: "INFO", source: "server1"
        , processId: "PRC2387613", title: "System 123 get started", created: "2014-01-13H03:31:12.349Z").
  Event.Category(code: "START", name: "Start")
  Event.Category(code: "INTERACT", name: "Interaction")
  Event.Category(code: "STOP", name: "Stop")

  DetailedEvent(id: 123439887656, categoryCode: "START", severityLevel: "INFO", processId: "PRC2387613"
             ,  title: "System 123 get started" , created: "2014-01-13H03:31:12.349", info: "E.g. XML with details of start.").
  
  DetailedEvent.Category(code: "START", name: "Start", desc: "Activity started.")
  DetailedEvent.Category(code: "INTERACT", name: "Interaction", desc: "Interaction performed.")
  DetailedEvent.Category(code: "STOP", name: "Stop", desc: "Activity started", desc: "Activity stopped.")
</pre>
  
Practicality of this entity set in everyday life is doubtful, but at least 
some interesting use cases can be imagined in future iterations. 
For instance JMS queue can receive log message from some remote system and transactionally store in DB(XA 2 phase commit).
It's easy to imagine millions of records for events to check performance(reading/writing), as another case.
Another "typical" case is workflow. A field ${processId} can be used to group events for some business process.
A field ${source} can be process name. CEP rules can be implemented somewhere. Sample rule: suspended case after series of 'INTERACT' events.
Warning about this sleeping process can be sent (e.g. as email, sms, or new event with severityLevel = 'WARN').

<h4><a id="2_1_2_DAOs">2.1.2. DAOs (or Mappers in ORMs)</a></h4>
Core DAO is <b>EventDao</b>. Event categories can have own DAO if time allows. 

<h3><a id="2_2_Data_high_level">2.2. Data high-level structure</a></h3>
To maximize simplicity for ORM inheritance hierarchy  '<em>1 table per class hierarchy</em>' approach is selected. 
Tables can look like:
<div>
<img src="img/events_tables.jpg" alt="Tables" />
</div>

<pre>
 Table event_categories(code varchar(16) {PK}, name varchar(100) {UNQ}, description longvarchar).
 Table events(id long {PK}, category_code varchar(16) {FK}, severity varchar(5)
        , source varchar(100), process_id varchar(100), title varchar(100), created timestamp, details longvarchar).
</pre>

<h3><a id="2_3_Project_structure">2.3. Project structure</a></h3>
Project is organised as directory structure with hierarchy of selected frmk names and approaches.

For instance if we need to checkout how 'Java SE 7' + Spring JDBC templates, path to impl module could be:
<em>/java_se7_sql/approaches/spring</em>. Root dirs e.g. 'java_se7_sql' can be considered as "autonomous" group of modules. They can contain 
subtrees of modules with some reusable members (e.g. commons, api).

<div class="note">  
NOTE: If tree looks too "deep", flattening can be applied. Sample - 'java_se7_sql' (it could be e.g. 'lang/java/se/7/sql').
</div>  

<h3><a id="2_4_Build">2.4. Build</a></h3>
For now main build tool is <b>maven</b> v3+, but gradle is in considerations too.<br>
Typical command is <b>'mvn -e clean test'</b>.
OS specific scripts will be provided for win7+(and maybe cygwin) and linux(sh) for now. 
They should be consider as hints/tips and main artefacts are DDL/DML files.
For DBs basic setup instructions can be found in corresponding <b>configs</b> subdirs. 
DDLs and DMLs with initial data used in tests were added as e.g. SQL scripts.
For example, if you need to create ETR tables in Postgresql, check <b>configs/sql_db_samples/pgsql/sql/create_tables.sql</b>.  

<div>
<img src="img/testing_workflow_basics.jpg" alt="Test workflow" />
</div>

<h2><a id="3_Persistence_DAO">3. Persistence DAO approaches overview</a></h2>
Java persistence has handful major paths and a lot of impl frmk-s. The lowest level is JDBC. It has 4 driver types. 
This project will embrace type 4 (pure Java driver). One step above of abstraction is JPA spec. It gradually replaced JEE entity beans. 
You'll see a few impls here. ORM allows to move abstraction up and developers can (theoretically) focus in Java dev rather than diving in SQL. 
In reality many business DB structures, especially legacy ones, have so "ORM incompatible" features (denormalization, absence of OO inheritance support), 
enterprise dev-s still need to dive on SQL (and/or stored procedures) level.<br>
Because there are tons of docs about persistence around, only short descriptions of approaches are provided below. 
Key config artefacts, classes, sample code snippets for one particular DAO operations (e.g. retrieve event) are provided. 
Code, context specific readme files and configs are considered here as detailed actionable docs.
<p>
	JDBC connection config note: pretty often you can find <b>db.properties</b> file in resources folder.
	It has sample connection config info e.g. for derby: 
	<pre>
# JDBC connection:
jdbc.driver=org.apache.derby.jdbc.ClientDriver
jdbc.url=jdbc:derby://localhost:1527/eventium
jdbc.username=etracker
jdbc.password=some_password
	</pre>
	For other DBs you only need to copy/paste their specific values from similar db* files.
</p>

OK, let's get started.

<h3><a id="3_1_JDBC">3.1. JDBC</a></h3>
Class <b>EventDaoImpl</b> uses <b>DbConnectionFactoryl</b>.It, in turn, goes fo DB settings to <b>db.properties</b> via <b>DbConnectionSettingsHolder</b>.
For 1 time category loading <b>EventCategoryCache</b> is used. For now no 2nd level caching is used to make things simple.<br>
Code fragment for <b>retrieveEvent</b>:
	<pre>
String queryString = "select id, title, category_code, severity, source, process_id, created from events where id = ?";
try (PreparedStatement statement = connection.prepareStatement(queryString,
		ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY)) {
	statement.setLong(1, eventId);
	ResultSet resultSet = statement.executeQuery();
	boolean firstExist = resultSet.first();
	</pre>
Notice Java SE7 style for resource allocation.

<h2><a id="4_Disclaimers">4. Disclaimers</a></h2>
This section describes what this project is NOT about and what to be aware of while perusing its artefacts.
<ul id="lines">
	<li>Code and configs are for quick start in particular combination of frmk-s only.
		Production ready code definitely requires more polishing, e.g. "what if"s handling, NOP situation catching etc.</li>
	<li>There is no goal to show all advanced features of used frmk-s. More specific projects to be created if time allows.</li>
	<li>In production systems reusability is one of key non-functional requirements. 
		This project follows this practice only partially as "side feature" because main goal is 
		to just show working basic combination, without forcing learner to jump through all hoops/levels of dependencies.
		Code is expected to be repeated, with reasonable level of sanity. Consider subprojects as relatively independent modules.</li> 	
	<li>Pragmatism(and a sort of laziness) is strong force to have <em>good enough</em> amount of frmk combinations.
		Missed combinations are hopefully can be figured out from provided ones. </li>
	<li>This project assumes you have basic knowledge in back-end development area, familiar at least with Java, SQL.</li>
	<li>At least from beginning only the most popular modern and stable frmk-s versions to be selected. 
		Elder versions maybe get addressed when project itself comes to age. Funny part is: these now modern versions will be old soon :).</li>
	<li>Project is in status "pet PoC, to play around", can be removed at any time without warning.</li>	
</ul>

<h2><a id="5_Abbreviations">5. Abbreviations</a></h2>

<table>
	<thead>
		<tr>
			<th>Abbrev</th>
			<th>Definition</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>frmk</td>
			<td>framework</td>
		</tr>
		<tr>
			<td>config</td>
			<td>configuration</td>
		</tr>
		<tr>
			<td>CRUD</td>
			<td>Create/Read/Update/Delete</td>
		</tr>
		<tr>
			<td>NOP</td>
			<td>Null Pointer (exception)</td>
		</tr>
		
		<tr>
			<td>OSS</td>
			<td>Open Source Software</td>
		</tr>
		<tr>
			<td>dict</td>
			<td>dictionary</td>
		</tr>
		<tr>
			<td>DAO</td>
			<td>Data Access Object</td>
		</tr>
		<tr>
			<td>ORM</td>
			<td> Object Relational Mapping</td>
		</tr>
		<tr>
			<td>DB</td>
			<td>database</td>
		</tr>
		<tr>
			<td>PROD</td>
			<td>Production</td>
		</tr>
		<tr>
			<td>DEV</td>
			<td>Development</td>
		</tr>
		<tr>
			<td>TX</td>
			<td>Transaction</td>
		</tr>
		<tr>
			<td>ACID</td>
			<td> Atomic Consistent Isolated Durable (about TX)</td>
		</tr>
		<tr>
			<td>PK</td>
			<td>Primary Key</td>
		</tr>
		<tr>
			<td>FK</td>
			<td>Foreign Key</td>
		</tr>
		<tr>
			<td>env</td>
			<td>environment</td>
		</tr>
		<tr>
			<td>param</td>
			<td>parameter</td>
		</tr>
		<tr>
			<td>dir</td>
			<td>directory</td>
		</tr>
		<tr>
			<td>desc</td>
			<td>description</td>
		</tr>
		<tr>
			<td>CEP</td>
			<td>Complex Event Processing</td>
		</tr>
	</tbody>
</table>

<div class="footer">
<hr>
| Version: 0.7 | Updated: 2014-03-30 | &copy; MerioSol, 2014 |
</div>

</body>

</html>