<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta httpEquiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Event tracker (ETR)</title>
<link href="css/main.css" rel="stylesheet" type="text/css"/>
</head>
<body>

<body>
<h1>Event tracker (ETR)</h1>

<table>
	<tbody>
		<tr>
			<td>Project:</td>
			<td>Event tracker</td>
		</tr>
		<tr>
			<td>Inception:</td>
			<td>2014-01-13</td>
		</tr>
		<tr>
			<td>Goal:</td>
			<td>
			Based on sample of event domain model show how different combinations of industry popular
			(Java) frameworks(frmk-s)/approaches can be used to handle events. For persistence entity CRUD operations in different DBs to be explored.</td>
		</tr>
	</tbody>
</table>

<h2>Contents</h2>
<ul>
	<li><a href="#Introduction">Introduction</a></li>
	<li><a href="#1_Requirements">1. Requirements/wishes/dreams</a></li>
	<li><a href="#1_1_Language">1.1. Language/frmk combinations</a></li>
	<li><a href="#1_2_Traits_to_consider">1.2. Traits to consider/embrace in selected persistent frmk-s</a></li>
	<li><a href="#1_3_Sample_test">1.3. Sample test cases for persistent frmk-s</a></li>
	<li><a href="#1_4_Implemented_approaches">1.4. Implemented approaches for persistent frmk-s</a></li>
	<li><a href="#2_Design">2. Design</a></li>
    <li><a href="#2_1_Class_high_level">2.1. Class high level structure</a></li>
    <li><a href="#2_1_1_POJOs">2.1.1. POJOs</a></li>
    <li><a href="#2_1_2_DAOs">2.1.2. DAOs (or Mappers in ORMs)</a></li>
    <li><a href="#2_2_Data_high_level">2.2. Data high-level structure</a></li>
    <li><a href="#2_3_Project_structure">2.3. Project structure</a></li>
    <li><a href="#2_4_Build">2.4. Build</a></li>
	<li><a href="#3_Persistence_DAO">3. Persistence DAO approaches overview</a></li>
	<li><a href="#3_1_JDBC">3.1. JDBC</a></li>
	<li><a href="#3_2_MyBatis">3.2. MyBatis</a></li>
	<li><a href="#3_2_1_MyBatis_XML">3.2.1. MyBatis XML</a></li>
	<li><a href="#3_2_2_MyBatis_Annot">3.2.2. MyBatis Annotations</a></li>
	<li><a href="#3_2_3_MyBatis_Annot_Spring">3.2.3. MyBatis Annotations with Spring DI</a></li>
	<li><a href="#3_3_Spring">3.3. Spring JDBC templates</a></li>
	<li><a href="#3_4_Hibernate">3.4. Hibernate</a></li>
	<li><a href="#3_4_1_Hibernate">3.4.1. Hibernate XML</a></li>
	<li><a href="#3_4_2_Hibernate_JPA">3.4.2. Hibernate JPA</a></li>
	<li><a href="#3_4_3_Hibernate_Spring">3.4.3. Hibernate Spring</a></li>
	<li><a href="#3_4_3_1_Hibernate_Spring_XML">3.4.3.1. Hibernate Spring XML</a></li>
	<li><a href="#3_4_3_2_Hibernate_Spring_Annot">3.4.3.2. Hibernate Spring Annotations</a></li>
	<li><a href="#3_4_3_3_Hibernate_Spring_Annot_JPA">3.4.3.3. Hibernate Spring Annotations JPA</a></li>
	<li><a href="#3_5_NoSQL_DBs">3.5. NoSQL DBs</a></li>
	<li><a href="#3_5_1_NoSQL_Cassandra">3.5.1. NoSQL Cassandra</a></li>
	<li><a href="#3_5_2_NoSQL_Solr">3.5.2. NoSQL Solr</a></li>
	<li><a href="#3_6_Performance">3.6. Performance</a></li>
    <li><a href="#4_Disclaimers">4. Disclaimers</a></li>
    <li><a href="#5_Abbreviations">5. Abbreviations</a></li>
</ul>
	
<h2><a id="Introduction">Introduction</a></h2>
There are tons of approaches to work with popular frmks e,g, for databases persistence. It's easy to get lost among them even if you're seasoned developer.
Once you start this endeavour, you realise that documentation varies from frmk to frmk in details and quality, 
sample code and configs are not for combination you assess, particular versions of frmk-s don't 
live together well. Forums - though useful, sometimes more confuse than help. It's especially common when the newest frmk versions are emerged
(notice this set of projects generally grabs the latest stable version of whichever frmk).<br> 
Another way to look at it: you joined new team. They use some combination of frmk-s which you didn't try. 
Codebase is large and not easy to grasp at once. Performance optimizations and bug fixes/workarounds can greatly reduce code readability. 
Yes, there are books, forums, guru fellows who can help out. But forums can mislead(for instance discuss elder frmk versions), gurus are busy
, and you want to see sample actionable code and run it now, learn in a matter of minutes how 
typical combination of those frmk-s works, how much config/code it "consumes". This project tries to 
embrace it via providing code snippets and configs which proven to work for particular frmk-s(generally the newest on time of addition).  

<h2><a id="1_Requirements">1. Requirements/wishes/dreams</a></h2>
Use cases are extremely simple from high level:
<div>
<img src="img/main_use_cases.jpg" alt="Main use cases" />
</div>

For 'Manage Event' main scenarios are: 'create','update','delete','retrieve'(a few methods e.g. per category or severity, sorted by date, paginated). 
Actors/users can be humans or machines. As a sample: event producer can generate events and send them to topic/queue. 
Event consumers can be users who monitor events via dashboards. WebSocket clients can setup tcp 
connection from browser to topic/queue consumers and listen to new events in real time. 
Consumers can be also CEP(Complex Event Processing) systems. They can detect predetermined patterns 
(e.g. 10 ERROR events from one source during 1 minute) and generate alerts(events themselves). Some sort of AI/machine learning can be applied too if time allows. 
Another area is BPM (Business Process Management). They can be launched by events (or particular steps triggered) or produce events.
So only imagination(and author lifespan) limits cases where events can be explored.

<h3><a id="1_1_Language">1.1. Language/frmk combinations</a></h3>
Current selection snapshot:

<pre>
(lang: Java SE v7) (frmk: JDBC v4+ | JPA v2+ | Spring v4+ | Hibernate v4+ | Mybatis v3+) 
(DB: SQL: (derby v10+ | mysql v5+| pgsql v9+) NoSQL: (Cassandra 2+ | Solr 4.7+)) (config: XML | Annotations).
</pre>

<div class="note">  
TODO: Consider Spring Data for persistence.
</div>  
<p>
You can ask why for DBs there are no e.g. Oracle, IBM DB2. They are solid, matured DBs. For now they are ignored 
for the sake of DB setup simplicity(e.g. try to find oracle for win7 64x machine which doesn't eat a few gigs of your HDD). 
Only immensely popular, easily available and open source DBs are selected. 
</p>

<div class="note">  
TODO: Well, it would be fair to add at least one of big guys DB (Oracle?) and stored procedures via JDBC can be explored.
</div>  
<p>
	Side notes:
	<ul>
		<li>It's incredible hard to embrace all combinations, so only some "mainstream" will be selected.</li>
		<li>"Container less" variations are considered only. JPA is the closest to JavaEE though.
		It's selected to avoid any clutter of additional configuring and dependencies from any EE container.
		Despite of it those testing DAOs will likely be used in EE containers for testing web-middleware-backend path.</li>
		<li>Some of frmk-s can be combined in "chains" e.g. (JPA + Spring + Hibernate). Folders and odcs will help to determine which combination is supported.</li>
		<li>No embedded DBs/modes are chosen. They are perceived as too far from PROD ready apps. Apache Derby (or JavaDB as modern name) has embedded mode. 
		You can test it if you wish.</li> 
	</ul>
</p>

<p>
	Current iteration (Mar 2014) already embraced planned SQL and NoSQL DBs persistence. Next iterations can embrace e.g.:
	<ul>
		<li>(JavaEE: version: (v6 | v7) ; profile: (web | full))
		<li>(lang: (Java SE 7 | JVM: (groovy v2+ | scala)) | python | perl | MS.Net: (c#))
		<li>  (DB: SQL: (Oracle)) (NoSQL: (MongoDB | Neo4j)) (idea is to embrace major NoSQL DB types: key/value or columnar, document, graph)
		<li>2nd level caching (notice ehcache is already used in a few persistence combinations)	 
	</ul>
</p>

<h3><a id="1_2_Traits_to_consider">1.2. Traits to consider/embrace in selected persistent frmk-s</a></h3>
<ul>
	<li>How easy to code/config a solution.</li>
	<li>Transaction(TX) support for ACID DBs(mostly SQL, but e.g. graph DB neo4j supports ACID too).</li>
	<li>XA distributed TX support (2 phase commits; JavaEE container is required).</li>
	<li>Date handling support (on very basic level; as a sample of not totally primitive data type).</li>
	<li>PK support. Client and DB side PK generation. Interesting case is complex keys support. Many legacy databases have composite keys.</li>
	<li>How easily Object/Relational mismatch is handled(those inheritance hierarchies).</li>
	<li>"Reconfigurability" (especially for env specific params).</li>
	<li>Pagination support (can be critical for large storage).</li>
	<li>Lazy loading (again critical for big data).</li>
	<li>Large data types support(for now long string is enough; e.g. via Clob or longvarchsr).</li>
	<li>Performance: latency, throughput.</li>
	<li>Memory consumption.</li>
	<li>Multi-threading support(how frmk-s sustain concurrent use; mutasker external lib can be used for load tests).</li>
	<li>Security (secured passwords, connections etc. Can be too large topic for this small project).</li>
	<li>Caching(consider <em>ehcache</em> as a sample).</li>
	<li>i18n(e.g. using UTF-8 charset for data).</li>
</ul>

<h3><a id="1_3_Sample_test">1.3. Sample test cases for persistent frmk-s</a></h3>
<ul>
	<li>Create event</li>
	<li>Update event fields</li>
	<li>Retrieve event by ID</li>
	<li>Retrieve limited amount of recent events(useful for feeds)</li>
	<li>Retrieve events for period (check cases where some or all date params are null)</li>
	<li>Delete event by ID</li>
</ul>

<h3><a id="1_4_Implemented_approaches">1.4. Implemented approaches for persistent frmk-s</a></h3>
Base dir is <b>projects/java_se7_sql/approaches</b>.
<table>
	<thead>
		<tr>
			<th>Approach</th>
			<th>Module path</th>
		</tr>
	</thead>		
	<tbody>
		<tr>
			<td>Cassandra/CQL</td>
			<td>cassandra/cql</td>
		</tr>
		<tr>
			<td>Hibernate/JPA/Annotations</td>
			<td>hibernate/jpa/annot</td>
		</tr>
		<tr>
			<td>Hibernate/Spring/Annotations</td>
			<td>hibernate/spring/annot</td>
		</tr>
		<tr>
			<td>Hibernate/Spring/JPA/Annotations</td>
			<td>hibernate/spring/jpa/annot</td>
		</tr>
		<tr>
			<td>Hibernate/Spring/XML</td>
			<td>hibernate/spring/xml</td>
		</tr>
		<tr>
			<td>Hibernate/XML</td>
			<td>hibernate/xml</td>
		</tr>
		<tr>
			<td>JDBC</td>
			<td>jdbc</td>
		</tr>
		<tr>
			<td>MyBatis/Annotations</td>
			<td>mybatis/annot</td>
		</tr>
		<tr>
			<td>MyBatis/Spring/Annotations</td>
			<td>mybatis/spring/annot</td>
		</tr>
		<tr>
			<td>MyBatis/XML</td>
			<td>mybatis/xml</td>
		</tr>
		<tr>
			<td>Solr/Direct</td>
			<td>solr/direct</td>
		</tr>
		<tr>
			<td>Spring/Templates</td>
			<td>spring/templates</td>
		</tr>
		
		
	</tbody>
</table>


It's expected for codebase to show some of them, but not all. Each module should describe what feature set is implemented. 

<h2><a id="2_Design">2. Design</a></h2>
Main idea of design is to create easily 'buildable' mini projects frmk which allows to quickly add and test frmk-s combination.
To simplify at least one aspect of system entities are planned to be used exactly the same and considered as "frozen".

<h3><a id="2_1_Class_high_level">2.1. Class high level structure</a></h3>
Domain and DAO classes:
<div>
<img src="img/etr_main_persistence_classes.jpg" alt="Main persistence classes" />
</div>
DAO interfaces - more details: 
<div>
<img src="img/etr_dao_interfaces_detailed.jpg" alt="DAO interfaces" />
</div>

<h4><a id="2_1_1_POJOs">2.1.1. POJOs</a></h4>
Main POJO classes to play with are: 
<pre>
  Event(id: long, category: Event.Category, severityLevel: enum(INFO/WARN/ERROR/FATAL)
        , source: string, processId: string, title: short_string, created: date_time).
</pre>

Supplement entity is dict of event categories: 
<pre>
  Event.Category(code: string, name: string). 
</pre>

These classes are suitable for lists and eager relationships mapping.<br>
For more detailed info subclasses are to be used(likely in the next iteration):

<pre>
  DetailedEvent extends Event (info: long_string).
  DetailedEvent.Category extends Event.Category(desc: long_string).
</pre>
   
They are expected to be used only for individual entity editing.  

Sample:
<pre>
  Event(id: 123439887656, categoryCode: "START", severityLevel: "INFO", source: "server1"
        , processId: "PRC2387613", title: "System 123 get started", created: "2014-01-13H03:31:12.349Z").
  Event.Category(code: "START", name: "Start")
  Event.Category(code: "INTERACT", name: "Interaction")
  Event.Category(code: "STOP", name: "Stop")

  DetailedEvent(id: 123439887656, categoryCode: "START", severityLevel: "INFO", processId: "PRC2387613"
             ,  title: "System 123 get started" , created: "2014-01-13H03:31:12.349", info: "E.g. XML with details of start.").
  
  DetailedEvent.Category(code: "START", name: "Start", desc: "Activity started.")
  DetailedEvent.Category(code: "INTERACT", name: "Interaction", desc: "Interaction performed.")
  DetailedEvent.Category(code: "STOP", name: "Stop", desc: "Activity started", desc: "Activity stopped.")
</pre>
  
Practicality of this entity set in everyday life is doubtful, but at least 
some interesting use cases can be imagined in future iterations. 
For instance JMS queue can receive log message from some remote system and transactionally store in DB(XA 2 phase commit).
It's easy to imagine millions of records for events to check performance(reading/writing), as another case.
Another "typical" case is workflow. A field ${processId} can be used to group events for some business process.
A field ${source} can be process name. CEP rules can be implemented somewhere. Sample rule: suspended case after series of 'INTERACT' events.
Warning about this sleeping process can be sent (e.g. as email, sms, or new event with severityLevel = 'WARN').

<h4><a id="2_1_2_DAOs">2.1.2. DAOs (or Mappers in ORMs)</a></h4>
Core DAO is <b>EventDao</b>. Event categories can have own DAO if time allows. 

<h3><a id="2_2_Data_high_level">2.2. Data high-level structure</a></h3>
To maximize simplicity for ORM inheritance hierarchy  '<em>1 table per class hierarchy</em>' approach is selected. 
Tables can look like:
<div>
<img src="img/events_tables.jpg" alt="Tables" />
</div>

<pre>
 Table event_categories(code varchar(16) {PK}, name varchar(100) {UNQ}, description longvarchar).
 Table events(id long {PK}, category_code varchar(16) {FK}, severity varchar(5)
        , source varchar(100), process_id varchar(100), title varchar(100), created timestamp, details longvarchar).
</pre>

<h3><a id="2_3_Project_structure">2.3. Project structure</a></h3>
Project is organised as directory structure with hierarchy of selected frmk names and approaches.

For instance if we need to checkout how 'Java SE 7' + Spring JDBC templates, path to impl module could be:
<em>/java_se7_sql/approaches/spring</em>. Root dirs e.g. 'java_se7_sql' can be considered as "autonomous" group of modules. They can contain 
subtrees of modules with some reusable members (e.g. commons, api).

<div class="note">  
NOTE: If tree looks too "deep", flattening can be applied. Sample - 'java_se7_sql' (it could be e.g. 'lang/java/se/7/sql').
</div>  

<h3><a id="2_4_Build">2.4. Build</a></h3>
For now main build tool is <b>maven</b> v3+, but gradle is in considerations too.<br>
Typical command is <b>'mvn -e clean test'</b>.
OS specific scripts will be provided for win7+(and maybe cygwin) and linux(sh) for now. 
They should be consider as hints/tips and main artefacts are DDL/DML files.
For DBs basic setup instructions can be found in corresponding <b>configs</b> subdirs. 
DDLs and DMLs with initial data used in tests were added as e.g. SQL scripts.
For example, if you need to create ETR tables in Postgresql, check <b>configs/sql_db_samples/pgsql/sql/create_tables.sql</b>.  

<div>
<img src="img/testing_workflow_basics.jpg" alt="Test workflow" />
</div>

<h2><a id="3_Persistence_DAO">3. Persistence DAO approaches overview</a></h2>
Java persistence has handful major paths and a lot of impl frmk-s. The lowest level is JDBC. It has 4 driver types. 
This project will embrace type 4 (pure Java driver). One step above of abstraction is JPA spec. It gradually replaced JEE entity beans. 
You'll see a few impls here. ORM allows to move abstraction up and developers can (theoretically) focus in Java dev rather than diving in SQL. 
In reality many business DB structures, especially legacy ones, have so "ORM incompatible" features (de-normalization, absence of OO inheritance support), 
enterprise dev-s still need to dive on SQL (and/or stored procedures) level.<br>
Because there are tons of docs about persistence around, only short descriptions of approaches are provided below. 
Key config artefacts, classes, sample code snippets for one particular DAO operations (e.g. retrieve event) are provided. 
Code, context specific readme files and configs are considered here as detailed actionable docs.
<p>
	JDBC connection config note: pretty often you can find <b>db.properties</b> file in resources folder.
	It has sample connection config info e.g. for derby: 
	<pre>
# JDBC connection:
jdbc.driver=org.apache.derby.jdbc.ClientDriver
jdbc.url=jdbc:derby://localhost:1527/eventium
jdbc.username=etracker
jdbc.password=some_password
	</pre>
	For other DBs you only need to copy/paste their specific values from similar db* files.
</p>

OK, let's get started.

<h3><a id="3_1_JDBC">3.1. JDBC</a></h3>
Class <b>EventDaoImpl</b> uses <b>DbConnectionFactoryl</b>.It, in turn, goes for DB settings to <b>db.properties</b> via <b>DbConnectionSettingsHolder</b>.
For 1 time category loading <b>EventCategoryCache</b> is used. For now no 2nd level caching is used to make things simple.<br>
Code fragment for <b>retrieveEvent</b>:
	<pre>
String queryString = "select id, title, category_code, severity, source, process_id, created from events where id = ?";
try (PreparedStatement statement = connection.prepareStatement(queryString,
		ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY)) {
	statement.setLong(1, eventId);
	ResultSet resultSet = statement.executeQuery();
	boolean firstExist = resultSet.first();
	</pre>
Notice Java SE7 style for resource allocation.

<h3><a id="3_2_MyBatis">3.2. MyBatis</a></h3>
MyBatis (former iBatis) is ORM suitable to deal with complex DB structures (especially legacy). 
Dev-s need to know SQL. But it means more power and freedom in finding balanced OO-DB mappings.

<h3><a id="3_2_1_MyBatis_XML">3.2.1. MyBatis XML</a></h3>
XML is classical config approach. File <b>mybatis-config.xml</b> has link to DB properties and mappers. Fragment:
	<pre>
&lt;configuration&gt;
    &lt;properties resource=&quot;com/meriosol/etr/dao/db.properties&quot; /&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;com/meriosol/etr/dao/mapper/EventMapper.xml&quot;/&gt;
    &lt;/mappers&gt;
	</pre>	
	
File <b>EventMapper.xml</b> stores SQL expressions e.g. for event retrieval:
	<pre>
&lt;mapper namespace=&quot;com.meriosol.etr.dao.mapper.EventMapper&quot;&gt;
	&lt;sql id=&quot;eventsTableName&quot;&gt;events&lt;/sql&gt;
	&lt;sql id=&quot;eventCategoriesTableName&quot;&gt;event_categories&lt;/sql&gt;
	&lt;sql id=&quot;baseEventFields&quot;&gt;title, category_code, severity , source , process_id, created&lt;/sql&gt;

	&lt;sql id=&quot;joinedSelectBaseForEvents&quot;&gt;select e.id as &quot;event_id&quot;, e.title as &quot;event_title&quot;, ec.code as &quot;category_code&quot;,
		ec.name as &quot;category_name&quot;,
		e.severity as &quot;event_severity&quot;, e.source as &quot;event_source&quot;,e.process_id as &quot;event_process_id&quot;, e.created as
		&quot;event_created&quot;
		from
		&lt;include refid=&quot;eventsTableName&quot;/&gt;
		e left join
		&lt;include refid=&quot;eventCategoriesTableName&quot;/&gt;
		ec on e.category_code = ec.code
	&lt;/sql&gt;
	...
	&lt;select id=&quot;retrieveEvent&quot; resultMap=&quot;eventResultMap&quot;&gt;
		&lt;include refid=&quot;joinedSelectBaseForEvents&quot;/&gt; where id = #{id}
	&lt;/select&gt;
	&lt;resultMap id=&quot;eventResultMap&quot; type=&quot;Event&quot;&gt;
		&lt;id property=&quot;id&quot; column=&quot;event_id&quot;/&gt;
		&lt;result property=&quot;title&quot; column=&quot;event_title&quot;/&gt;
	...
	</pre>	
Interface <b>EventMapper</b> has corresponding method <b>Event retrieveEvent(Long eventId)</b>. 
MyBatis uses this method name to look through in mapper XML for SQL. Once query get executed, resultset is mapped to Event POJO.
File <b>ehcache.xml</b> has terracota ehcache config. Fragment:
	<pre>	
&lt;ehcache&gt;
    &lt;diskStore path=&quot;/tmp/etr/ehcache&quot; /&gt;

    &lt;defaultCache maxElementsInMemory=&quot;10000&quot; eternal=&quot;false&quot;
                  timeToIdleSeconds=&quot;120&quot; timeToLiveSeconds=&quot;120&quot; overflowToDisk=&quot;true&quot;
                  diskSpoolBufferSizeMB=&quot;30&quot; maxElementsOnDisk=&quot;10000000&quot;
                  diskPersistent=&quot;false&quot; diskExpiryThreadIntervalSeconds=&quot;120&quot;
                  memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;
	</pre>	

In order to load MyBatis classes DAO impl uses:
	<pre>	
    ... inputStream = Resources.getResourceAsStream(MYBATIS_RESOURCE_CONFIG);
        this.sessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
    </pre>    

Retrieve event then looks like:
    <pre>    
    public Event retrieveEvent(Long eventId) {
        Event event;
        try (SqlSession session = this.sessionFactory.openSession(TransactionIsolationLevel.SERIALIZABLE)) {
            EventMapper eventMapper = session.getMapper(EventMapper.class);
            event = eventMapper.retrieveEvent(eventId);
            session.commit();
        }
        return event;
    }
    </pre>    

<h3><a id="3_2_2_MyBatis_Annot">3.2.2. MyBatis Annotations</a></h3>
For annotation use config <b>mybatis-config.xml</b> references to POJO classes e.g.:

    <pre>    
    &lt;mappers&gt;
        &lt;mapper class=&quot;com.meriosol.etr.dao.mapper.EventMapper&quot;/&gt;
        &lt;mapper class=&quot;com.meriosol.etr.dao.mapper.EventCategoryMapper&quot;/&gt;
    &lt;/mappers&gt;
    </pre>    

Our familiar retrieve event config moves to that mapper interface:

    <pre>    
    @Select(DmlCommands.RETRIEVE_EVENT)
    @Options(useCache = true)
    @MapKey("id")
    @Results({
            @Result(property = "id", column = "id"),
            @Result(property = "category", column = "category_code", javaType = Event.Category.class
                    , one = @One(select = "com.meriosol.etr.dao.mapper.EventCategoryMapper.retrieveEventCategory")),
            @Result(property = "title", column = "title"),
            @Result(property = "severity", column = "severity"),
            @Result(property = "source", column = "source"),
            @Result(property = "processId", column = "process_id"),
            @Result(property = "created", column = "created")
    })
    Event retrieveEvent(Long eventId);
    </pre>     

For caching annotation is used:
    <pre>    
    @CacheNamespace(implementation = org.mybatis.caches.ehcache.EhcacheCache.class)
    </pre>     

<h3><a id="3_2_3_MyBatis_Annot_Spring">3.2.3. MyBatis Annotations with Spring DI</a></h3>
Spring can be used to simplify config. File <b>applicationContext.xml</b> has MyBatis config:

    <pre>    
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
        &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.meriosol.etr.domain&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
        &lt;property name=&quot;basePackage&quot; value=&quot;com.meriosol.etr.dao.mapper&quot;/&gt;
    &lt;/bean&gt;
    </pre>     

Mapper class is autowired:	
    <pre>    
    @Service("EventDaoService")
    public class EventDaoImpl implements EventDao {
        private static final Logger LOG = LoggerFactory.getLogger(EventDaoImpl.class);
        ...
        @Autowired
        private EventMapper eventMapper;
    </pre>     

<h3><a id="3_3_Spring">3.3. Spring JDBC templates</a></h3>
Spring context config fragment:
    <pre>    
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
    &lt;context:component-scan base-package=&quot;com.meriosol.etr.dao.impl&quot;/&gt;
    &lt;context:annotation-config/&gt;
    &lt;tx:annotation-driven/&gt;
    </pre>     

DAO impl is annotated as service. Spring finds it via component scanning. Dependencies:	
    <pre>    
@Service("EventDaoService")
public class EventDaoImpl implements EventDao {
    private NamedParameterJdbcTemplate namedParameterJdbcTemplate;
    private JdbcTemplate jdbcTemplate;
    private EventCategoryCache eventCategoryCache;
    </pre>
	
Class <b>NamedParameterJdbcTemplate</b> is useful for cases when named param map is preferable way to set params.
Event load method uses this template:
    <pre>    
    interface DmlCommands {
        String BASE_SELECT = "select id, category_code, title, severity , source , process_id, created " +
                "from events ";
        String RETRIEVE_EVENT = BASE_SELECT + " where id = :id";
	....	
    @Transactional
    public Event retrieveEvent(Long eventId) {
        Map<String, Long> namedParameters = Collections.singletonMap("id", eventId);
        try {
            return this.namedParameterJdbcTemplate.queryForObject(DmlCommands.RETRIEVE_EVENT
					, namedParameters, new EventMapper());
        } catch (EmptyResultDataAccessException e) {
            return null;
        }
    }
    </pre>     
	
<h3><a id="3_4_Hibernate">3.4. Hibernate</a></h3>
Hibernate ORM is immensely popular, de-facto standard for cases where you can manage DB structure, adjust it to domain class hierarchies. 
Ideas from it lead to Java EE JPA spec. SQL like lang - HQL is used to describe queries.
 
<h3><a id="3_4_1_Hibernate">3.4.1. Hibernate XML</a></h3>
Main config file for Hibernate / XML approach is <b>hibernate.cfg.xml</b>. In its session factory element there are mapper config links:

    <pre>    
&lt;hibernate-configuration&gt;
    &lt;session-factory&gt;
        &lt;!-- Database connection settings --&gt;
        &lt;property name=&quot;connection.driver_class&quot;&gt;org.apache.derby.jdbc.ClientDriver&lt;/property&gt;
        &lt;property name=&quot;connection.url&quot;&gt;jdbc:derby://localhost:1527/eventium&lt;/property&gt;
        &lt;property name=&quot;connection.username&quot;&gt;etracker&lt;/property&gt;
        &lt;property name=&quot;connection.password&quot;&gt;some_password&lt;/property&gt;
		...

        &lt;mapping resource=&quot;com/meriosol/etr/dao/hibernate/Event.hbm.xml&quot;/&gt;
        &lt;mapping resource=&quot;com/meriosol/etr/dao/hibernate/EventCategory.hbm.xml&quot;/&gt;
    &lt;/session-factory&gt;
    </pre>    

Notice DB config settings are right there. I didn't find way to extract them into "traditional" <b>db.properties</b>.<br>
Mapper file <b>Event.hbm.xml</b> fragment:
    <pre>    
&lt;hibernate-mapping package=&quot;com.meriosol.etr.domain&quot;&gt;
    &lt;class name=&quot;Event&quot; table=&quot;events&quot;&gt;
        &lt;id name=&quot;id&quot; type=&quot;long&quot; column=&quot;id&quot;&gt;
            &lt;generator class=&quot;native&quot;/&gt;
        &lt;/id&gt;

        &lt;many-to-one name=&quot;category&quot; class=&quot;Event$Category&quot; column=&quot;category_code&quot;
                     cascade=&quot;save-update&quot; not-null=&quot;false&quot; lazy=&quot;false&quot; fetch=&quot;join&quot;/&gt;
        &lt;property name=&quot;severity&quot; column=&quot;severity&quot;&gt;
            &lt;type name=&quot;org.hibernate.type.EnumType&quot;&gt;
                &lt;param name=&quot;enumClass&quot;&gt;com.meriosol.etr.domain.Event$Severity&lt;/param&gt;
            &lt;/type&gt;
        &lt;/property&gt;
	...				 
   </pre>    
This mapper binds domain class <b>Event</b> with table <b>events</b>. For ID value generation native DB vendor feature is to be used.<br>
Many-to-one relationship for field <b>category</b> is bound as <b>events.category_code</b> to <b>Event.Category</b>
(Event$Category in config because '$' should be used for static nested classes) 
and <b>event_categories.code</b> DB field (as described in <b>EventCategory.hbm.xml</b>).<br>

DAO impl class has reference to session factory that initialized like this:
    <pre>    
	Configuration configuration = new Configuration();
	configuration.configure();
	ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().applySettings(configuration.getProperties()).build();
	this.sessionFactory = configuration.buildSessionFactory(serviceRegistry);
    </pre>    

Fragment of event retrieval:
    <pre>    
	session = this.sessionFactory.openSession();
	transaction = session.beginTransaction();
	event = (Event) session.get(Event.class, eventId);
	transaction.commit();
    </pre>    
   
<h3><a id="3_4_2_Hibernate_JPA">3.4.2. Hibernate JPA</a></h3>
Quite interesting combination. JPA spec was mainly based on ideas from different ORMs including Hibernate. 
So, what we have as a result (at least on basic level), let's see below.<br>
Main config file <b>persistence.xml</b> has mappers(annotation approach here) and DB connection settings:
    <pre>
&lt;persistence-unit name=&quot;com.meriosol.etr.dao.jpa&quot;&gt;
        &lt;class&gt;com.meriosol.etr.dao.entity.EventEntity&lt;/class&gt;
        &lt;class&gt;com.meriosol.etr.dao.entity.EventCategoryEntity&lt;/class&gt;

        &lt;properties&gt;
            &lt;property name=&quot;javax.persistence.jdbc.driver&quot; value=&quot;org.apache.derby.jdbc.ClientDriver&quot;/&gt;
    </pre>    

Because this time annotation approach is used and by system it's paramount to remain domain POJOs intact, artificial entities were created.
Fragment of EventEntity: 
    <pre>
@Entity
@Table(name = "events")
public class EventEntity {
    @Id
    @Column(name = "id", insertable = true, updatable = false)
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "category_code", nullable = true, insertable = true, updatable = true)
    private EventCategoryEntity category;

    @Column(name = "severity", insertable = true, nullable = true, updatable = true)
    @Enumerated(EnumType.STRING)
    private Event.Severity severity;
	...
    </pre>
	
Some concerns regarding annotations:
<ul>
	<li>One of concerns is using changeable names in annotations. What if some of DBs has table name <b>mucho_eventos</b> for example?</li>
	<li>Another concern is how not to get lost in annotated POJOS in really big enterprise systems. Especially without IDE support.</li>
	<li>When configs are spread around classes it's a bit hard to troubleshoot / fix in non-trivial systems(especially with legacy DBs).</li>
</ul>

Factory <b>EventDaoFactory</b> init-s <b>javax.persistence.EntityManagerFactory</b>:
    <pre>
	...
    private static final String PERSISTENT_UNIT_NAME = "com.meriosol.etr.dao.jpa";
	...
    private EventDaoFactory() {
        this.entityManagerFactory = Persistence.createEntityManagerFactory(PERSISTENT_UNIT_NAME);
    }
    </pre>

DAO impl then uses it e.g. for event loading:
    <pre>
	entityManager = this.entityManagerFactory.createEntityManager();
	transaction = entityManager.getTransaction();
	transaction.begin();

	CriteriaBuilder cb = entityManager.getCriteriaBuilder();
	CriteriaQuery<EventEntity> cq = cb.createQuery(EventEntity.class);
	Root<EventEntity> eventEntityRoot = cq.from(EventEntity.class);
	cq.select(eventEntityRoot);
	String pkFieldName = "id";
	String idParamName = "id";
	cq.where(cb.equal(eventEntityRoot.<Long>get(pkFieldName) , cb.parameter(Long.class, idParamName)));

	Query query = entityManager.createQuery(cq);
	query.setParameter(idParamName, eventId);

	try {
		eventEntity = (EventEntity) query.getSingleResult();
	} catch (NoResultException e) {
		LOG.info("No entity found for eventId='{}'. In some cases it can be normal", eventId);
	}

	transaction.commit();
    </pre>

Well, JPA criteria API is type safe, but a heck verbose, even for simple cases. 
I had hard time to figure out how to build queries for more advanced ones. Let's call Spring for help.

<h3><a id="3_4_3_Hibernate_Spring">3.4.3. Hibernate Spring</a></h3>
Hibernate+Spring is popular de-facto combination for light-weight(vs entity beans / JavaEE) and often "container-less" variants.

<h3><a id="3_4_3_1_Hibernate_Spring_XML">3.4.3.1. Hibernate Spring XML</a></h3>
In Hibernate samples above you could notice DB connection info had to be set in hibernate xml configs. 
Spring relieves this config "tension" and now <b>db.properties</b> get back to scene. Along with connection settings it has hibernate specific e.g.:
    <pre>	
hibernate.hbm2ddl.auto = false
hibernate.dialect = org.hibernate.dialect.DerbyTenSevenDialect
hibernate.cache.provider_class = org.hibernate.cache.internal.NoCacheProvider
    </pre>	

Spring <b>applicationContext.xml</b> points to this file via placeholder way:
    <pre>	
    &lt;context:property-placeholder location=&quot;com/meriosol/etr/dao/db.properties&quot;/&gt;
    </pre>	

Hibernate session factory in "Spring" style:

    <pre>	
&lt;bean id=&quot;sessionFactory&quot;
	  class=&quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean&quot;&gt;
	&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;property name=&quot;mappingResources&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;com/meriosol/etr/dao/hibernate/Event.hbm.xml&lt;/value&gt;
            &lt;value&gt;com/meriosol/etr/dao/hibernate/EventCategory.hbm.xml&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    ....
    </pre>    
    
DAO impl is loaded from app context:
    <pre>    
    ApplicationContext context = new ClassPathXmlApplicationContext("com/meriosol/etr/dao/applicationContext.xml");
    return (EventDao) context.getBean("EventDaoService");
    </pre>    

SessionFactory is autowired in this DAO impl:
    <pre>    
@Service("EventDaoService")
public class EventDaoImpl implements EventDao {
...
    @Autowired
    private SessionFactory sessionFactory;
    ...
    </pre>    

All this "jazz" makes event loading deadly simple:
    <pre>    
    @Transactional
    public Event retrieveEvent(Long eventId) {
        Session session = this.sessionFactory.openSession();
        return (Event) session.get(Event.class, eventId);
    }
    </pre>    
	
<h3><a id="3_4_3_2_Hibernate_Spring_Annot">3.4.3.2. Hibernate Spring Annotations</a></h3>
For annotated classes one small amendment is needed in <b>applicationContext.xml</b> - package scanner:
    <pre>    
&lt;bean id=&quot;sessionFactory&quot;
	  class=&quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean&quot;&gt;
	&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
	&lt;property name=&quot;packagesToScan&quot;&gt;
	    &lt;list&gt;
            &lt;value&gt;com.meriosol.etr.dao.entity&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    </pre>    

DAO impl is loaded the same way as in XML approach and SessionFactory is autowired the same way. Event load:
    <pre>    
    @Transactional(readOnly = true, propagation = Propagation.REQUIRED)
    public Event retrieveEvent(Long eventId) {
        Session session = this.sessionFactory.getCurrentSession();
        EventEntity eventEntity = (EventEntity) session.get(EventEntity.class, eventId);
        return EventEntityTransformUtil.transform(eventEntity);
    }
    </pre>
    
<b>EventEntityTransformUtil</b> used to transform <b>EventEntity</b> to basic (annotation free) <b>Event</b>.    

<h3><a id="3_4_3_3_Hibernate_Spring_Annot_JPA">3.4.3.3. Hibernate Spring Annotations JPA</a></h3>	
This combination is even more incredible than those above. It's where established de-facto meet specs and new additions.<br>
To avoid repeating the same as above (see Hibernate/Spring) let's pay attention to differences. 
Major difference is using <b>EntityManagerFactory</b> in <b>applicationContext.xml</b>:
    <pre>    
	...
&lt;bean id=&quot;entityManagerFactory&quot; class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt;
	&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
	&lt;property name=&quot;persistenceUnitName&quot; value=&quot;jpaTest&quot;/&gt;
	&lt;property name=&quot;packagesToScan&quot;&gt;
		&lt;list&gt;
			&lt;value&gt;com.meriosol.etr.dao.entity&lt;/value&gt;
		&lt;/list&gt;
	&lt;/property&gt;
	&lt;property name=&quot;jpaVendorAdapter&quot;&gt;
		&lt;bean class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;&gt;
		&lt;/bean&gt;
	&lt;/property&gt;
	
   &lt;bean id=&quot;entityManager&quot; class=&quot;org.springframework.orm.jpa.support.SharedEntityManagerBean&quot;&gt;
        &lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactory&quot;/&gt;
    &lt;/bean&gt;
	...
    </pre>    

That entity manager is autowired in DAO impl:
    <pre> 
@Service("EventDaoService")
public class EventDaoImpl implements EventDao {
    @Autowired
    private EntityManager entityManager;
    </pre> 

Event load uses this EntityManager:
    <pre> 
@Transactional(readOnly = true, propagation = Propagation.REQUIRED)
public Event retrieveEvent(Long eventId) {
	CriteriaBuilder cb = this.entityManager.getCriteriaBuilder();
	CriteriaQuery<EventEntity> cq = cb.createQuery(EventEntity.class);
	Root<EventEntity> eventEntityRoot = cq.from(EventEntity.class);
	cq.select(eventEntityRoot);
	String pkFieldName = "id";
	String idParamName = "id";
	cq.where(cb.equal(eventEntityRoot.<Long>get(pkFieldName), cb.parameter(Long.class, idParamName)));

	Query query = this.entityManager.createQuery(cq);
	query.setParameter(idParamName, eventId);

	EventEntity eventEntity = null;
	try {
		eventEntity = (EventEntity) query.getSingleResult();
	} catch (NoResultException e) {
		LOG.info("No entity found for eventId='{}'. In some cases it can be normal", eventId);
	}
    </pre> 


<h3><a id="3_5_NoSQL_DBs">3.5. NoSQL DBs</a></h3>	
So far persistence and ORMs described access to relational(or "SQL") DBs. 
Because of growing popularity of alternative NoSQL world it would be strange not to touch this area.
Cassandra and Solr were selected because I already used them in some projects. 
But likely other flavours will be added(e.g. MongoDB with Json storage, Neo4J for graphs).	
<h3><a id="3_5_1_NoSQL_Cassandra">3.5.1. NoSQL Cassandra</a></h3>	
Cassandra allows to distribute its keyspaces and "tables"(column families) across many machines with P2P replication with eventual consistency(so don't expect "real-time" one). 
Let's use 1 host for simplicity now. Familiar config <b>db.properties</b> has now cassandra connection specific properties:
    <pre>    
cassandra.hosts=127.0.0.1
cassandra.keyspace=eventium
cassandra.username=etracker
cassandra.password=some_password	
    </pre>    

DAO impl has a few helpers:
    <pre>    
public class EventDaoImpl implements EventDao {
    private DbSessionFactory dbSessionFactory;
    private EventCategoryCache eventCategoryCache;
    private EventByCreatedSliceCrud eventByCreatedSliceCrud;
    </pre>   
	
<b>DbSessionFactory</b> loads Cassandra connection via cluster:
    <pre>    
Session obtainNewSession(String hosts, String keyspace, String username, String password) {
	String[] hostsArray = hosts.split(",");
	Cluster cluster = Cluster.builder()
			.addContactPoints(hostsArray).withCredentials(username, password)
			.withRetryPolicy(DowngradingConsistencyRetryPolicy.INSTANCE)
			.withReconnectionPolicy(new ConstantReconnectionPolicy(100L))
			.build();
	Metadata metadata = cluster.getMetadata();
	return cluster.connect();
}
    </pre>

Event load code fragment shows how this session is used:	
    <pre>    
	...
	String selector = "SELECT " + EVENT_COLUMNS
			+ " FROM " + getFullEventTableName(keyspace) + " WHERE id = ? LIMIT 1;";
	PreparedStatement statement = session.prepare(selector);
	BoundStatement boundStatement = statement.bind(eventId);
	ResultSet results = session.execute(boundStatement);
	Row eventRow = null;
	if (results != null) {
		eventRow = results.one();
	}
    </pre>   
 
Class <b>EventByCreatedSliceCrud</b> is used to load event IDs sorted according to rule "show me the latest first", which is typical for events.<br>
Tricky thing about column families design is they should be adjusted to particular use cases. 
For instance in order to load events with sorted severity level, another "table" has to be created and own CRUD supported. I suspect it can make SQL DB dev-s crazy.
  	

<h3><a id="3_5_2_NoSQL_Solr">3.5.2. NoSQL Solr</a></h3>	
Solr is distributed reverse indexer of documents(e.g. articles/news). Lucent engine is used for search in indices (Solr cores, almost "tables").<br>
Solr core has fields which can be indexed or used as (meta)data. Textual fields is only one data type sample supported by engine.
As with the most previous approaches, we have config <b>db.properties</b>. But with Solr specific properties e.g.:
    <pre>    
# Solr connection:
solr.url=http://localhost:8983/solr

# Solr cores:
solr.core.event_categories=event_categories
solr.core.events=events
    </pre>    

DAO impl uses these helpers:
    <pre>    
public class EventDaoImpl implements EventDao {
    private SolrServerFactory solrServerFactory;
    private EventCategoryCache eventCategoryCache;
    </pre>    
	
Class <b>SolrServerFactory</b> "knows" how to get connection for particular Solr core. 
Inner class <b>SolrServerHolder</b> stores <b>Map&lt;SolrCoreCode, SolrServer&gt; servers</b>.
Solr server is loaded by instantiation of <b>HttpSolrServer</b>:
    <pre>
    HttpSolrServer httpSolrServer = new HttpSolrServer(this.settings.getSolrCoreUrl(solrCoreCode)); 
    </pre> 

Event solr document load code fragment:	
    <pre>
    String queryString = "id:" + eventId;
    SolrQuery solrQuery = new SolrQuery();
    solrQuery.set("q", queryString);

    Event event = null;
    QueryResponse response = null;
    try {
        response = solrServer.query(solrQuery);
        if (response != null) {
            SolrDocumentList results = response.getResults();
            if (results != null && results.size() > 0) {
                if (results.size() > 1) {
                    throw new EtrException(String.format("Too many events found for ID='%s'!", eventId));
                }
                SolrDocument solrDocument = results.get(0);
                event = buildEventFromResultSet(solrDocument);
            }
        }
    } catch (SolrServerException e) {
        throw new EtrException(e);
    }
	...	
    </pre>  
	
For now(April 2014) this is last approach to tackle. If time allows, more ones will be added. 
	
<h3><a id="3_6_Performance">3.6. Performance</a></h3>
Performance is quite big topic itself (along with non-functional such as security, maintainability/extensibility, availability, reliability/durability, flexibility etc).
In current state of project minimal attention was paid to enhance performance. Only occasionally connection poolers are used, for instance.
In some future statement execution latency, traffic throughput (size, speed) for statements needs to be explored and in case of bottlenecks fixed. 
But for beginning all these executions need to be measured.
<div class="note">  
TODO: Performance comparison would be nice to see(especially in multi-threaded scenarios). 
</div>
	
<h2><a id="4_Disclaimers">4. Disclaimers</a></h2>
This section describes what this project is NOT about and what to be aware of while perusing its artefacts.
<ul id="lines">
    <li>Code and configs are for quick start in particular combination of frmk-s only.
        Production ready code definitely requires more polishing, e.g. "what if"s handling, NPE situation catching etc.</li>
    <li>There is no goal to show all advanced features of used frmk-s. More specific projects to be created if time allows.</li>
    <li>In production systems reusability is one of key non-functional requirements. 
        This project follows this practice only partially as "side feature" because main goal is 
        to just show working basic combination, without forcing learner to jump through all hoops/levels of dependencies.
        Code is expected to be repeated, with reasonable level of sanity. Consider subprojects as relatively independent modules.</li>     
    <li>Pragmatism(and a sort of laziness) is strong force to have <em>good enough</em> amount of frmk combinations.
        Missed combinations are hopefully can be figured out from provided ones. </li>
    <li>This project assumes you have basic knowledge in back-end development area, familiar at least with Java, SQL.</li>
    <li>At least from beginning only the most popular modern and stable frmk-s versions to be selected. 
        Elder versions maybe get addressed when project itself comes to age. Funny part is: these now modern versions will be old soon.</li>
    <li>Project is in status "pet PoC, to play around", can be removed at any time without warning.</li>    
</ul>

<h2><a id="5_Abbreviations">5. Abbreviations</a></h2>

<table>
    <thead>
        <tr>
            <th>Abbrev</th>
            <th>Definition</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>frmk</td>
            <td>framework</td>
        </tr>
        <tr>
            <td>config</td>
            <td>configuration</td>
        </tr>
        <tr>
            <td>CRUD</td>
            <td>Create/Read/Update/Delete</td>
        </tr>
        <tr>
            <td>NOP</td>
            <td>Null Pointer (exception)</td>
        </tr>
        
        <tr>
            <td>OSS</td>
            <td>Open Source Software</td>
        </tr>
        <tr>
            <td>dict</td>
            <td>dictionary</td>
        </tr>
        <tr>
            <td>DAO</td>
            <td>Data Access Object</td>
        </tr>
        <tr>
            <td>ORM</td>
            <td> Object Relational Mapping</td>
        </tr>
        <tr>
            <td>DB</td>
            <td>database</td>
        </tr>
        <tr>
            <td>DI</td>
            <td>Dependency Injection</td>
        </tr>
        <tr>
            <td>PROD</td>
            <td>Production</td>
        </tr>
        <tr>
            <td>DEV</td>
            <td>Development</td>
        </tr>
        <tr>
            <td>TX</td>
            <td>Transaction</td>
        </tr>
        <tr>
            <td>ACID</td>
            <td> Atomic Consistent Isolated Durable (about TX)</td>
        </tr>
        <tr>
            <td>PK</td>
            <td>Primary Key</td>
        </tr>
        <tr>
            <td>FK</td>
            <td>Foreign Key</td>
        </tr>
        <tr>
            <td>env</td>
            <td>environment</td>
        </tr>
        <tr>
            <td>param</td>
            <td>parameter</td>
        </tr>
        <tr>
            <td>dir</td>
            <td>directory</td>
        </tr>
        <tr>
            <td>desc</td>
            <td>description</td>
        </tr>
        <tr>
            <td>CEP</td>
            <td>Complex Event Processing</td>
        </tr>
    </tbody>
</table>

<div class="footer">
<hr>
| Version: 0.9 | Updated: 2014-04-02 | &copy; MerioSol, 2014 |
</div>

</body>

</html>